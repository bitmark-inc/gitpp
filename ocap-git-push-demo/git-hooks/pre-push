#!/bin/sh

# This hook is called with the following parameters:
#
# $1 -- Name of the remote to which the push is being done
# $2 -- URL to which the push is being done
#
# If pushing without using a named remote those arguments will be equal.
#
# Information about the commits which are being pushed is supplied as lines to
# the standard input in the form:
#
#   <local ref> <local sha1> <remote ref> <remote sha1>
#

remote="${1}"
url="${2}"

# uncomment to enable
# ===================
#debug=yes
verbose=yes
# ===================

if [ X"${verbose}" = X"yes" ]
then
  printf 'script: %s\n' "${0}"
  printf 'script: git repo: %s @ %s\n' "${remote}" "${url}"
fi

# internal parameters
tmp_signed_invocation="$(mktemp tmp-signed-invocation-XXXXXXXX)"
capability_notes=caps

# accept a yes/no response from /dev/tty
GetYorN() {
  local yorn junk prompt

  prompt="${1}"
  while :
  do
    read -p "${prompt}: [Y/N]? " yorn junk < /dev/tty
    case "${yorn}" in
      ([yY]|[yY][eE][sS])
        return 0
        ;;
      ([nN]|[nN][oO])
        return 1
        ;;
      (*)
        printf 'please answer yes or no\n'
        ;;
    esac
  done
  return 1
}

# accumulate all branches and commits hashes for attaching notes
remote_refs=''
notes_ids=''
while read local_ref local_sha remote_ref remote_sha
do
  if [ X"${verbose}" = X"yes" ]
  then
    printf 'script: local_ref: %s [SHA:%s]  remote_ref: %s [SHA:%s]\n' "${local_ref}" "${local_sha}" "${remote_ref}" "${remote_sha}"
  fi

  for rev in $(git rev-list "${local_sha}...${remote_sha}")
  do
    printf 'script: object to commit: %s\n' "${rev}"
    notes_ids="${notes_ids} ${rev}"
  done

  remote_refs="${remote_refs} ${remote_ref}"
done

[ X"${debug}" = X"yes" ] && set -x


sign="node --trace-warnings @@JS_DIR@@/sign-invocation.js"
invoke="node --trace-warnings @@JS_DIR@@/invoke.js"

[ X"${verbose}" = X"yes" ] && sign="${sign} -v" && invoke="${invoke} -v"
[ X"${debug}" = X"yes" ] && sign="${sign} -v -v" && invoke="${invoke} -v -v"


rm -f "${tmp_signed_invocation}"

cleanup() {
  rm -f "${tmp_signed_invocation}"
}
trap cleanup INT EXIT

# simulate secure enclave
sign_invocation() {

  local url="${1}"; shift
  local name="${1}"; shift
  local email="${1}"; shift

  # user: secret key, public key, and did:key from public key and keyId(always 0 for did:key:)
  local USER_SEC='3LftyxxRPxMFXwVChk14HDybE2VnBnPWaLX31WreZwc8V8xCCuoGL7dcyxnwkFXa8D7CZBwAGWj54yqoaxa7gUne'
  local USER_PUB='CXbgG2vPnd8FWLAZHoLRn3s7PRwehWsoMu6v1HhN9brA'
  local USER_DID='did:key:z6MkqyrirHAq8Acicq1FyNJGd9R7D1DW7Q8A3v1qqZfP4pdY'
  local USER_KID=0

  local ISSUER_DID='did:key:z6MkvRsV39xVQc8HevAQwCqEw18DwrEtzVLz8NJY15NtfMmD'
  local CAPABILITY_TARGET="ssh://${url}?key=${ISSUER_DID}"

  local capability_list='@@CAPABILITY@@'

  printf 'ENCLAVE: push to git repo: %s\n' "${url}"
  printf 'ENCLAVE: as user:          %s <%s>\n' "${name}" "${email}"
  printf 'ENCLAVE: for branches:     %s\n' "${*}"

  local capability
  local n=0
  for capability in ${capability_list}
  do
    n=$((n + 1))
    printf 'ENCLAVE: %2d id: %s\n' "${n}" "${capability}"
    eval local cap_"${n}=\"${capability}\""
  done
  read -p 'ENCLAVE: select capability: ' n < /dev/tty

  eval capability=\"\${cap_${n}}\"

  if [ -z "${capability}" ]
  then
    printf 'ENCLAVE: rejected all capabilities\n'
    return 1
  fi

  printf 'ENCLAVE: using capability: %s\n' "${capability}"

  GetYorN 'ENCLAVE: sign invocation' || return 1

  ${sign} \
    --capability-url="${capability}" \
    --target="${CAPABILITY_TARGET}" \
    --user="${USER_DID}" \
    --user-sec="${USER_SEC}" \
    --user-key="${USER_KID}" > "${tmp_signed_invocation}"
  return $?
}

# ask envclave sign then invoke
if [ -z "${remote_refs}" ]
then
  printf 'script: nothing to push\n'
  exit 0
else
  name="$(git config --get user.name)"
  email="$(git config --get user.email)"

  if ! sign_invocation "${url}" "${name}" "${email}" ${remote_refs}
  then
    printf 'script: signing failed\n'
    exit 2
  fi

  if ! ${invoke} < "${tmp_signed_invocation}" ${remote_refs}
  then
    printf 'script: push is forbidden\n'
    exit 1
  fi
fi

# save the signed invocations to the commits notes
git notes --ref="${capability_notes}" prune
for rev in ${notes_ids}
do
  printf 'script: adding capability note to: %s\n' "${rev}"
  (
    printf -- 'Note for %s added by %s <%s>\n' "${rev}" "${name}" "${email}"
    printf -- '-----BEGIN CAPABILITY-----\n'
    b64encode -r invocation < "${tmp_signed_invocation}"
    printf -- '-----END CAPABILITY-----\n'
  ) | git notes --ref="${capability_notes}" add --force --file -
done

git push --no-verify origin refs/notes/caps

exit 0
